<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0" />
  <title>Bullet Journal</title>
  <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@400;700&display=swap" rel="stylesheet">
  <style>
    * { box-sizing: border-box; }
    html, body {
      font-family: 'IBM Plex Mono', monospace;
      margin: 0;
      padding: 0;
      height: 100%;
      background: transparent;
      color: #eee;
      text-transform: uppercase;
      overflow: hidden;
    }
    ::-webkit-scrollbar { display: none; }

    #wrapper {
      display: flex;
      flex-direction: row;
      height: 100%;
      width: 100%;
      padding: 32px 20px;
      gap: 32px;
    }

    .panel {
      width: 240px;
      flex-shrink: 0;
      overflow-y: auto;
      max-height: calc(100vh - 60px);
      position: relative;
    }

    #journal-panel {
      flex: 1;
      display: flex;
      flex-direction: column;
      min-width: 0;
    }

  b {
  color: inherit;
  font-weight: bold;
}

    .card {
      border: 1px solid #444;
      border-radius: 12px;
      margin-bottom: 24px;
      padding: 20px;
      background: none;
    }

    .card h2 {
      font-size: 0.75rem;
      margin: 0 0 16px;
      border-bottom: 1px solid #444;
      padding-bottom: 6px;
      font-weight: 700;
    }

    ul {
  list-style-type: disc;
  margin: 0 0 14px 20px;
  padding-left: 20px;
}

li.line-text {
  color: #eee;
  font-size: 0.75rem;
  margin-bottom: 6px;
  text-transform: none;
}
@media (prefers-color-scheme: light) {
  li.line-text {
    color: #000;
  }
}


    .line-text:not(.entry-line .line-text) {
  display: block;
  padding-left: 20px; /* visually align with checkbox blocks */
}

    .item {
      font-size: 0.75rem;
      margin-bottom: 10px;
      color: #888;
      display: flex;
      justify-content: space-between;
      align-items: center;
      cursor: pointer;
    }

    *:focus {
  outline: none !important;
  box-shadow: none !important;
}

    .item.active {
      font-weight: bold;
      color: #fff;
    }

    .item-controls {
      display: flex;
      gap: 6px;
    }

    .icon-btn {
      border: none;
      background: none;
      color: #aaa;
      cursor: pointer;
      font-size: 0.7rem;
      padding: 0;
    }

    .icon-btn:hover {
      color: #fff;
    }

    .add-collection-link {
      font-size: 0.7rem;
      margin-top: -6px;
      margin-bottom: 10px;
      display: inline-block;
      cursor: pointer;
      font-weight: bold;
    }

    #calendar-btn {
      position: absolute;
      top: 14px;
      left: 188px;
      font-size: 1.2rem;
      background: none;
      border: none;
      color: #eee;
      cursor: pointer;
    }

    .header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 18px;
    }

    #entry-title {
      font-size: 0.9rem;
      font-weight: bold;
      margin-bottom: 4px;
    }

    #entry-date {
      font-size: 0.7rem;
      color: #aaa;
    }

    #journal-content {
  flex: 1;
  overflow-y: auto;
  padding: 20px;
  max-width: none;
  margin: 0;
  font-size: 1rem;
  letter-spacing: 0.08em;
  font-weight: 400;
}

    .entry-line {
  display: flex;
  padding-left: 20px;
  align-items: center;
  gap: 6px;
  margin-bottom: 6px;
  padding: 2px 0;
}
    
.entry-line .line-text,
.line-text,
li.line-text {
  font-size: 0.7rem !important; /* âœ… small, uniform */
}
    
    .entry-line input[type="checkbox"] {
  appearance: none;
  width: 18px;
  height: 18px;
  border: 1px solid #888;
  border-radius: 4px;
  background: transparent;
  position: relative;
  cursor: pointer;
  flex-shrink: 0;
  pointer-events: auto;
}
    
.entry-line input[type="checkbox"]::before {
  content: '';
  display: block;
  width: 100%;
  height: 100%;
}

.entry-line input[type="checkbox"]:checked::before {
  content: "X";
  position: absolute;
  color: #fff;
  font-size: 0.7rem;
  font-weight: bold;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
}


    .line-text {
  padding: 3px 0;
  cursor: text;
  white-space: pre-wrap;
  border: none;
  outline: none;
}

    .line-text:focus {
  outline: none;
}

    .entry-line input[type="checkbox"]:focus,
.entry-line .line-text:focus {
  outline: none;
  box-shadow: none;
}

    #journal-panel:focus,
#journal-panel:focus-visible {
  outline: none;
  box-shadow: none;
}

strong { font-weight: bold; }
em { font-style: italic; }
del { text-decoration: line-through; }

    .entry-line .line-text {
      flex: 1;
      outline: none;
      min-height: 18px;
      padding: 2px 0;
      word-break: break-word;
      font-size: 0.7rem;
      outline: none;
      border: none;
      box-shadow: none;
    }

    .entry-line input[type="checkbox"]:checked + .line-text {
      text-decoration: line-through;
      opacity: 0.6;
    }

    .popup {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%,-50%);
  background: #222;
  border: 1px solid #666;
  padding: 20px;
  width: 280px;
  max-width: 95vw;
  z-index: 1000;
  border-radius: 10px;
  display: flex;
  flex-direction: column;
  gap: 12px;
  color: #eee;
}

.popup input,
.popup-buttons button {
  background: #333;
  color: #eee;
  border-color: #888;
}

    .popup h3 {
      font-size: 0.75rem;
      margin: 0;
    }

    .popup p {
      font-size: 0.65rem;
      margin: 0;
      line-height: 1.4;
    }

    .popup input {
      padding: 6px;
      font-family: 'IBM Plex Mono', monospace;
      background: none;
      border: 1px solid #444;
      color: #fff;
      font-size: 0.75rem;
      width: 100%;
    }

    .popup-buttons {
      display: flex;
      gap: 8px;
    }

  .popup-buttons button {
  flex: 1;
  padding: 6px;
  font-size: 0.7rem;
  font-weight: bold;
  border-radius: 6px;
  background: #444;
  color: #fff;
  border: 1px solid #888;
  cursor: pointer;
  transition: background 0.2s;
}

.popup-buttons button:hover {
  background: #666;
  color: #fff;
}

    #sync-status {
      position: fixed;
      bottom: 10px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 0.65rem;
      opacity: 0.8;
    }

    .calendar-dot {
      border-bottom: 2px solid #fff;
    }

    .calendar-today {
      background: #333;
      font-weight: bold;
    }

    .calendar-selected {
      outline: 2px solid #888;
    }

    @media (prefers-color-scheme: light) {
  html, body { color: #000; }
  .entry-line input[type="checkbox"]:checked + .line-text { color: #000; }
  .calendar-dot { border-bottom: 2px solid #000 !important; }

  .icon-btn,
  .add-collection-link,
  #calendar-btn {
    color: #000;
    border-color: #000;
  }

  .popup-buttons button {
    background: #000;
    color: #fff;
    border: 1px solid #fff;
  }
  
    .item.active {
    color: #000 !important; /* ðŸ‘ˆ override white in light mode */
  }

  .popup-buttons button:hover {
    background: #222;
    color: #fff;
  }
}

    @media (prefers-color-scheme: dark) {
      .calendar-dot { border-bottom: 2px solid #fff !important; }
    }

    @media (max-width: 700px) {
      #wrapper {
        flex-direction: column;
        padding: 20px 14px;
        gap: 20px;
      }
      .panel {
        width: 100%;
      }
      #journal-panel {
        min-height: 300px;
      }
    }
    #command-palette {
  position: fixed;
  z-index: 9999;
  background: #111;
  color: #fff;
  width: 260px;
  max-width: 100%;
  overflow: auto;
  padding: 10px;
  border-radius: 10px;
  border: 1px solid #555;
  top: 100px;
  left: 100px;
}

#command-palette input {
  width: 100%;
  padding: 6px;
  margin-bottom: 6px;
  background: #222;
  border: 1px solid #555;
  color: #fff;
  font-family: inherit;
  font-size: 0.75rem;
}

#command-options {
  display: flex;
  flex-direction: column;
  gap: 4px;
}

.command-option {
  padding: 6px;
  cursor: pointer;
  font-size: 0.75rem;
}
   
  li.line-text::marker {
  content: 'â€¢ ';
  color: #eee; /* default: dark mode */
}

@media (prefers-color-scheme: light) {
  li.line-text::marker {
    color: #000;
  }
}
  li.line-text {
  display: list-item !important;
  list-style-type: disc;
  margin-left: 20px;
  color: #eee;
  font-size: 0.75rem;
  text-transform: none;
}

li.line-text > .line-text-inner {
  display: inline !important;
  width: 100%;
  color: inherit;
  outline: none;
  background: transparent;
}

@media (prefers-color-scheme: light) {
  li.line-text {
    color: #000;
  }
}

.command-option.active {
  background: #444;
  color: #fff;
  font-weight: bold;
}
    #journal-wrapper {
  position: relative;
  flex: 1;
  overflow-y: auto;
}
.spinner {
  display: inline-block;
  width: 1em;
  height: 1em;
  border: 2px solid #888;
  border-top-color: transparent;
  border-radius: 50%;
  animation: spin 0.8s linear infinite;
  margin-right: 4px;
  vertical-align: middle;
}

@keyframes spin {
  to { transform: rotate(360deg); }
}
  </style>
</head>
<body>
  <div id="wrapper">
    <div class="panel">
      <div class="card" id="index-card">
        <h2>INDEX
          <button id="calendar-btn" title="Create new date">+</button>
        </h2>
        <div class="item" data-entry="yesterday">YESTERDAY</div>
        <div class="item" data-entry="today">TODAY</div>
        <div class="item" data-entry="tomorrow">TOMORROW</div>

        <h2 style="margin-top: 18px;">RECENTS
          <span id="recents-toggle" style="float: right; cursor: pointer;">â–¼</span>
        </h2>
        <div id="recent-entries" style="display: block;"></div>
      </div>

      <div id="collections-card" class="card">
        <h2>COLLECTIONS</h2>
        <span class="add-collection-link" onclick="toggleCollectionPopup()">+ ADD</span>
        <div id="collections-list"></div>
      </div>
    </div>

    <div id="journal-panel" class="card">
      <div class="header">
        <div>
          <div id="entry-title">DAILY LOG</div>
          <div id="entry-date">MON, APR 14</div>
        </div>
      </div>
      <div id="journal-wrapper">
  <div id="journal-content" class="notes"></div>
</div>
    </div>
  </div>

  <!-- POPUPS -->
  <div id="calendar-popup" class="popup" style="display: none;">
    <h3>DATE INPUT</h3>
    <p>PLEASE SELECT A DATE TO CREATE OR LOAD</p>
    <div id="calendar-header" style="display: flex; justify-content: space-between; align-items: center;">
      <button id="prev-month">&#8592;</button>
      <span id="calendar-month"></span>
      <button id="next-month">&#8594;</button>
    </div>
    <div id="calendar-grid" style="display: grid; grid-template-columns: repeat(7, 1fr); gap: 6px; margin: 12px 0;"></div>
    <div class="popup-buttons">
      <button id="calendar-create" disabled>GO</button>
      <button onclick="calendarPopup.style.display='none'">CANCEL</button>
    </div>
  </div>

  <div id="collection-popup" class="popup" style="display:none;">
    <h3>NEW COLLECTION</h3>
    <input id="new-collection-name" placeholder="Collection name" />
    <div class="popup-buttons">
      <button onclick="createCollection()">SAVE</button>
      <button onclick="toggleCollectionPopup()">CANCEL</button>
    </div>
  </div>

  <div id="rename-popup" class="popup" style="display:none;">
    <h3>RENAME COLLECTION</h3>
    <input id="rename-input" placeholder="New name" />
    <div class="popup-buttons">
      <button onclick="confirmRename()">SAVE</button>
      <button onclick="hideRenamePopup()">CANCEL</button>
    </div>
  </div>

  <div id="delete-popup" class="popup" style="display:none;">
    <h3>DELETE COLLECTION</h3>
    <p>ARE YOU SURE YOU WANT TO DELETE THIS COLLECTION?</p>
    <div class="popup-buttons">
      <button onclick="confirmDelete()">DELETE</button>
      <button onclick="hideDeletePopup()">CANCEL</button>
    </div>
  </div>

  <div id="sync-status">
    <span class="spinner" style="display:none;"></span>
    <span class="label">SYNCED</span>
  </div>

  <div id="command-palette" style="display: none;" class="popup" tabindex="-1">
  <input id="command-search" placeholder="Type a command..." autofocus />
  <div id="command-options"></div>
</div>
<script>
let currentMode = "daily";
let currentSlug = "";
let recentEntries = [];
let selectedCalendarDate = null;

  let blocks = []; // Global state: our array of blocks
let blockIdCounter = 0;

function createBlock(type = "text", content = "", props = {}) {
  return {
    id: `block-${blockIdCounter++}`,
    type,
    content,
    props
  };
}


function getTodaySlug(offset = 0) {
  const now = new Date();

  // Adjust for local time zone offset in minutes
  const localOffset = now.getTimezoneOffset(); // in minutes
  const adjusted = new Date(now.getTime() - localOffset * 60000);

  adjusted.setDate(adjusted.getDate() + offset);
  return adjusted.toISOString().slice(0, 10);
}

function encodeHTML(str) {
  return btoa(unescape(encodeURIComponent(str)));
}

function decodeHTML(str) {
  return decodeURIComponent(escape(atob(str)));
}

function extractVersion(html) {
  const match = html.match(/<!-- version:(.*?)-->/);
  return match ? new Date(match[1]) : new Date(0);
}

function updateStatus(text, syncing = false) {
  document.querySelector("#sync-status .label").textContent = text;
  document.querySelector("#sync-status .spinner").style.display = syncing ? "inline-block" : "none";
}

function formatPrettyDate(dateStr) {
  const d = new Date(dateStr);
  return d.toLocaleDateString("en-US", { weekday: "short", month: "short", day: "numeric" }).toUpperCase();
}

  function highlightActive(slug) {
  const today = getTodaySlug();
  const yest = getTodaySlug(-1);
  const tomo = getTodaySlug(1);

  document.querySelectorAll(".item").forEach(i => {
    const entry = i.dataset.entry;

    const isMatch =
      (entry === slug) ||
      (entry === "today" && slug === today) ||
      (entry === "yesterday" && slug === yest) ||
      (entry === "tomorrow" && slug === tomo);

    if (isMatch) {
      i.classList.add("active");
    } else {
      i.classList.remove("active");
    }
  });
}

  let isCommandMode = false;
let commandBuffer = "";

  function renderBlocks() {
  const contentEl = document.getElementById("journal-content");
  contentEl.innerHTML = "";

  let listBuffer = [];

  for (const block of blocks) {
    if (block.type === "list") {
      listBuffer.push(block);
      continue;
    }

    if (listBuffer.length) {
      const ul = document.createElement("ul");
      listBuffer.forEach(item => {
        ul.appendChild(renderBlock(item));
      });
      contentEl.appendChild(ul);
      listBuffer = [];
    }

    contentEl.appendChild(renderBlock(block));
  }

  // If it ends with a list
  if (listBuffer.length) {
    const ul = document.createElement("ul");
    listBuffer.forEach(item => {
      ul.appendChild(renderBlock(item));
    });
    contentEl.appendChild(ul);
  }
}

  function renderBlock(block) {
  const wrapper = document.createElement("div");
  wrapper.dataset.id = block.id;
  wrapper.dataset.type = block.type;
  wrapper.className = "block";

  let inner;

  if (block.type === "todo") {
    wrapper.classList.add("entry-line");

    const cb = document.createElement("input");
    cb.type = "checkbox";
    cb.checked = block.props.checked || false;
    cb.onchange = () => {
      block.props.checked = cb.checked;
      saveBlocks();
    };

    inner = document.createElement("div");
    inner.className = "line-text";
    inner.contentEditable = true;
    inner.innerHTML = block.content;
    inner.oninput = () => {
  block.content = inner.innerHTML;
  saveBlocks();
};

    wrapper.append(cb, inner);
  } else if (block.type === "divider") {
    return document.createElement("hr");
    } else if (block.type === "list") {
  const li = document.createElement("li");
  li.className = "line-text";
  li.contentEditable = true;
  li.innerHTML = block.content;
  li.oninput = () => {
    block.content = li.innerHTML;
    saveBlocks();
  };
  return li;
  } else {
    wrapper.className = "line-text";
    wrapper.contentEditable = true;
    wrapper.innerHTML = block.content;
    wrapper.oninput = () => {
      block.content = wrapper.innerHTML;
      saveBlocks();
    };
  }

  return wrapper;
}
  
function saveBlocks() {
  localStorage.setItem(`blocks-${currentMode}-${currentSlug}`, JSON.stringify(blocks));
  debounceSync(); // optional, if you're syncing
}


function smoothEntryTransition(newHtml) {
   const content = document.getElementById("journal-content");
  content.style.opacity = 0;
  setTimeout(() => {
    content.innerHTML = newHtml;

    normalizeJournalContent();

    // ðŸ©¹ Fix orphaned lines
    const orphanLines = content.querySelectorAll('.line-text:not(.entry-line .line-text)');
    orphanLines.forEach(textDiv => {
      const wrapper = document.createElement('div');
      wrapper.className = 'entry-line';

      const cb = document.createElement('input');
      cb.type = 'checkbox';
      cb.onchange = saveContent;

      textDiv.replaceWith(wrapper);
      wrapper.appendChild(cb);
      wrapper.appendChild(textDiv);
    });

    pushUndoState();
    content.style.opacity = 1;
  }, 120);
}

  
function loadContent(mode, slug, label, url) {
  currentMode = mode;
  currentSlug = slug;
  document.getElementById("entry-title").textContent = label;
  document.getElementById("entry-date").textContent = (mode === "daily") ? formatPrettyDate(slug) : "";

  highlightActive(slug);

  const content = document.getElementById("journal-content");
  const blockKey = `blocks-${mode}-${slug}`;
  const htmlKey = `bujocache-${mode}-${slug}`;
  const blockCache = localStorage.getItem(blockKey);
  const htmlCache = localStorage.getItem(htmlKey);

  try {
    if (blockCache) {
      blocks = JSON.parse(blockCache);
      blockIdCounter = blocks.length;
      renderBlocks();
      updateStatus("LOADED LOCAL BLOCKS");
    } else if (htmlCache) {
      const html = decodeHTML(htmlCache);
      blocks = parseHTMLToBlocks(html);
      blockIdCounter = blocks.length;
      renderBlocks();
      localStorage.setItem(blockKey, JSON.stringify(blocks)); // Save parsed blocks
      updateStatus("LOADED PARSED HTML");
    } else {
      blocks = [createBlock("text", "")];
      renderBlocks();
      updateStatus("EMPTY");
    }
  } catch (e) {
    console.error("Failed to load from cache", e);
    blocks = [createBlock("text", "")];
    renderBlocks();
    updateStatus("ERROR");
  }

  // Sync with GitHub (remote)
  fetch(url).then(res => res.ok ? res.text() : null).then(remote => {
    if (!remote) return;
    const remoteVer = extractVersion(remote);
    const localVer = extractVersion(htmlCache ? decodeHTML(htmlCache) : "");

    if (remoteVer > localVer) {
      blocks = parseHTMLToBlocks(remote);
      blockIdCounter = blocks.length;
      renderBlocks();
      localStorage.setItem(htmlKey, encodeHTML(remote));
      localStorage.setItem(blockKey, JSON.stringify(blocks)); // Save updated blocks
      updateStatus("LOADED SYNCED");

      setTimeout(() => {
        const editable = document.querySelector('#journal-content .line-text');
        if (editable) placeCaretAtEnd(editable);
      }, 150);
    }
  }).catch(() => updateStatus("OFFLINE"));
}


function forceCheckboxAttrs() {
  const content = document.getElementById("journal-content");
  content.querySelectorAll('input[type="checkbox"]').forEach(cb => {
    cb.checked ? cb.setAttribute("checked", "checked") : cb.removeAttribute("checked");
  });
}

  function serializeBlocksToHTML() {
  let html = "";
  let listBuffer = [];

  for (const block of blocks) {
    if (block.type === "todo") {
      const checked = block.props?.checked ? ' checked="checked"' : '';
      html += `<div class="entry-line"><input type="checkbox"${checked}><div class="line-text" contenteditable="true">${block.content}</div></div>\n`;
    } else if (block.type === "divider") {
      html += `<hr>\n`;
    } else if (block.type === "list") {
      listBuffer.push(`<li class="line-text">${block.content}</li>`);
    } else {
      if (listBuffer.length) {
        html += `<ul>\n${listBuffer.join("\n")}\n</ul>\n`;
        listBuffer = [];
      }
      html += `<div class="line-text" contenteditable="true">${block.content}</div>\n`;
    }
  }

  if (listBuffer.length) {
    html += `<ul>\n${listBuffer.join("\n")}\n</ul>\n`;
  }

  return html;
}
  function parseHTMLToBlocks(html) {
  const temp = document.createElement("div");
  temp.innerHTML = html;
  const parsed = [];

  for (const node of temp.childNodes) {
    if (node.nodeType === Node.COMMENT_NODE) continue;
    if (node.nodeType !== Node.ELEMENT_NODE) continue;

    if (node.tagName === "HR") {
      parsed.push(createBlock("divider", ""));
      continue;
    }

    // âœ… Checkbox block
    if (node.classList.contains("entry-line")) {
      const input = node.querySelector('input[type="checkbox"]');
      const text = node.querySelector(".line-text")?.innerHTML || "";
      parsed.push(createBlock("todo", text.trim(), { checked: input?.checked || false }));
      continue;
    }

    // âœ… Plain text block
    if (node.classList.contains("line-text")) {
      parsed.push(createBlock("text", node.innerHTML.trim()));
      continue;
    }

    // âœ… List item (`<ul><li class="line-text">...</li></ul>`)
    if (node.tagName === "UL") {
  const items = node.querySelectorAll("li.line-text");
  items.forEach(li => {
    parsed.push(createBlock("list", li.innerHTML.trim()));
  });
  continue;
}
  }

  return parsed;
}


function saveLocal() {
  const content = document.getElementById("journal-content");
  const html = `<!-- version:${new Date().toISOString()} -->\n${serializeBlocksToHTML()}`;
  localStorage.setItem(`bujocache-${currentMode}-${currentSlug}`, encodeHTML(html));
}

function syncRemote() {
  const content = document.getElementById("journal-content");
  const html = `<!-- version:${new Date().toISOString()} -->\n${serializeBlocksToHTML()}`;
  updateStatus("SYNCING...", true);
  fetch("https://bujolebron.netlify.app/.netlify/functions/dispatch", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ date: currentSlug, content: encodeHTML(html), mode: currentMode })
  }).then(res => updateStatus(res.ok ? "SYNCED" : "NETLIFY ERROR"))
    .catch(() => updateStatus("SYNC FAILED"));
}

function debounceSync() {
  clearTimeout(window._syncTimeout);
  window._syncTimeout = setTimeout(syncRemote, 1000);
}

function saveContent() {
  saveBlocks();
  pushUndoState();
}

let undoStack = [], redoStack = [];
function pushUndoState() {
  const content = document.getElementById("journal-content");
  undoStack.push(content.innerHTML);
  if (undoStack.length > 50) undoStack.shift();
  redoStack = [];
}

function undo() {
  const content = document.getElementById("journal-content");
  if (undoStack.length > 1) {
    redoStack.push(undoStack.pop());
    content.innerHTML = undoStack[undoStack.length - 1];
    saveContent();
  }
}

function redo() {
  const content = document.getElementById("journal-content");
  if (redoStack.length) {
    const state = redoStack.pop();
    undoStack.push(state);
    content.innerHTML = state;
    saveContent();
  }
}

// RECENTS
function renderRecents() {
  const box = document.getElementById("recent-entries");
  box.innerHTML = "";
  const today = getTodaySlug();
  const yest = getTodaySlug(-1);
  const tomo = getTodaySlug(1);
  recentEntries.filter(slug => ![today, yest, tomo].includes(slug)).forEach(slug => {
    const div = document.createElement("div");
    div.className = "item";
    div.dataset.entry = slug;
    div.textContent = slug;
    div.onclick = () => loadContent("daily", slug, "DAILY LOG", `https://raw.githubusercontent.com/lebron1212/bulletjournal/main/journals/indexes/journal-${slug}.html`);
    box.appendChild(div);
  });
}
document.getElementById("recents-toggle").onclick = () => {
  const box = document.getElementById("recent-entries");
  const expanded = box.style.display !== "none";
  box.style.display = expanded ? "none" : "block";
  document.getElementById("recents-toggle").textContent = expanded ? "â–¶" : "â–¼";
};

// CALENDAR
const calendarPopup = document.getElementById("calendar-popup");
const calendarGrid = document.getElementById("calendar-grid");
const calendarMonthLabel = document.getElementById("calendar-month");
const calendarCreateBtn = document.getElementById("calendar-create");
let calendarDate = new Date();

function openCalendarPopup() {
  calendarPopup.style.display = "flex";
  calendarCreateBtn.disabled = true;
  selectedCalendarDate = null;
  renderCalendar();
}

function renderCalendar() {
  const today = new Date();
  const month = calendarDate.getMonth();
  const year = calendarDate.getFullYear();
  const firstDay = new Date(year, month, 1).getDay();
  const daysInMonth = new Date(year, month + 1, 0).getDate();
  const dots = getDotDaysForMonth(year, month);
  calendarGrid.innerHTML = "";
  calendarMonthLabel.textContent = `${calendarDate.toLocaleString('default', { month: 'long' })} ${year}`;
  for (let i = 0; i < firstDay; i++) calendarGrid.appendChild(document.createElement("div"));
  for (let d = 1; d <= daysInMonth; d++) {
    const day = document.createElement("div");
    day.textContent = d;
    day.style.padding = "4px";
    day.style.border = "1px solid #333";
    day.style.textAlign = "center";
    day.style.cursor = "pointer";
    if (dots.has(d)) day.classList.add("calendar-dot");
    if (d === today.getDate() && year === today.getFullYear() && month === today.getMonth()) day.classList.add("calendar-today");
    if (selectedCalendarDate && selectedCalendarDate === `${year}-${String(month + 1).padStart(2, "0")}-${String(d).padStart(2, "0")}`) {
      day.classList.add("calendar-selected");
    }
    day.onclick = () => {
      selectedCalendarDate = `${year}-${String(month + 1).padStart(2, "0")}-${String(d).padStart(2, "0")}`;
      calendarCreateBtn.disabled = false;
      renderCalendar();
    };
    calendarGrid.appendChild(day);
  }
}

function getDotDaysForMonth(year, month) {
  const dots = new Set();
  Object.keys(localStorage).forEach(key => {
    if (key.startsWith("bujocache-daily-")) {
      const slug = key.split("bujocache-daily-")[1];
      const d = new Date(slug);
      if (d.getFullYear() === year && d.getMonth() === month) dots.add(d.getDate());
    }
  });
  return dots;
}

document.getElementById("calendar-btn").onclick = openCalendarPopup;
document.getElementById("prev-month").onclick = () => { calendarDate.setMonth(calendarDate.getMonth() - 1); renderCalendar(); };
document.getElementById("next-month").onclick = () => { calendarDate.setMonth(calendarDate.getMonth() + 1); renderCalendar(); };
calendarCreateBtn.onclick = () => {
  if (!selectedCalendarDate) return;
  calendarPopup.style.display = "none";

  loadContent("daily", selectedCalendarDate, "DAILY LOG", `https://raw.githubusercontent.com/lebron1212/bulletjournal/main/journals/indexes/journal-${selectedCalendarDate}.html`);

  setTimeout(() => {
    const editable = document.querySelector('#journal-content .line-text');
    if (editable) placeCaretAtEnd(editable);
  }, 250);
};

function toggleCollectionPopup() {
  const popup = document.getElementById("collection-popup");
  popup.style.display = (popup.style.display === "flex") ? "none" : "flex";
}


function hideRenamePopup() {
  document.getElementById("rename-popup").style.display = "none";
}

function hideDeletePopup() {
  document.getElementById("delete-popup").style.display = "none";
}

function createCollection() {
  const input = document.getElementById("new-collection-name");
  const name = input.value.trim().toUpperCase().replace(/\s+/g, "-");
  if (!name) return;

  const html = `<!-- version:${new Date().toISOString()} -->\n<div class="line-text" contenteditable="true">New collection: ${name}</div>`;

  fetch("https://bujolebron.netlify.app/.netlify/functions/dispatch", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ date: name, content: encodeHTML(html), mode: "collection" })
  }).then(() => {
    input.value = "";
    document.getElementById("collection-popup").style.display = "none";

    const localKey = "collections-list";
    const now = new Date().toISOString();

    // Update cached list with version
    const existing = JSON.parse(localStorage.getItem(localKey) || "[]");
    const updated = Array.from(new Set([name, ...existing]));

    localStorage.setItem(localKey, JSON.stringify(updated));
    localStorage.setItem(`${localKey}-version`, now); // ðŸ”¥ store version timestamp
    renderCollections(updated);
    loadContent("collection", name, name, `https://raw.githubusercontent.com/lebron1212/bulletjournal/main/journals/collections/collection-${name}.html`);

setTimeout(() => {
  const editable = document.querySelector('#journal-content .line-text');
  if (editable) placeCaretAtEnd(editable);
}, 250);
  });
}
function confirmRename() {
  const newName = document.getElementById("rename-input").value.trim().toUpperCase().replace(/\s+/g, "-");
  if (!newName || !window._renameTarget) return;

  fetch("https://bujolebron.netlify.app/.netlify/functions/dispatch", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ rename: window._renameTarget, to: newName, mode: "collection" })
  }).then(() => {
    hideRenamePopup();
    const updated = JSON.parse(localStorage.getItem("collections-list") || "[]")
      .map(s => s === window._renameTarget ? newName : s);
    localStorage.setItem("collections-list", JSON.stringify(updated));
    renderCollections(updated);
  });
}

function confirmDelete() {
  if (!window._deleteTarget) return;

  fetch("https://bujolebron.netlify.app/.netlify/functions/dispatch", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ delete: window._deleteTarget, mode: "collection" })
  }).then(() => {
    hideDeletePopup();

    // Unload if the deleted collection is currently loaded
    if (currentMode === "collection" && currentSlug === window._deleteTarget) {
      document.getElementById("journal-content").innerHTML = "";
      document.getElementById("entry-title").textContent = "DAILY LOG";
      document.getElementById("entry-date").textContent = "";
    }

    // Remove local cache
    const localKey = `bujocache-collection-${window._deleteTarget}`;
    localStorage.removeItem(localKey);

    const updated = JSON.parse(localStorage.getItem("collections-list") || "[]")
      .filter(s => s !== window._deleteTarget);

    localStorage.setItem("collections-list", JSON.stringify(updated));
    renderCollections(updated);
  });
}

function loadCollectionsList() {
  const box = document.getElementById("collections-list");
  const stored = localStorage.getItem("collections-list");
  let slugs = stored ? JSON.parse(stored) : [];
  renderCollections(slugs);

  fetch("https://api.github.com/repos/lebron1212/bulletjournal/contents/journals/collections")
  .then(res => res.ok ? res.json() : null)
  .then(data => {
    if (!data) return;

    const remoteSlugs = data
      .filter(i => i.name.startsWith("collection-") && i.name.endsWith(".html"))
      .map(i => i.name.replace("collection-", "").replace(".html", ""));

    const remoteVersion = new Date().toISOString();
    const cachedVersion = localStorage.getItem("collections-list-version");

    if (!cachedVersion || new Date(remoteVersion) > new Date(cachedVersion)) {
      localStorage.setItem("collections-list", JSON.stringify(remoteSlugs));
      localStorage.setItem("collections-list-version", remoteVersion);
      renderCollections(remoteSlugs);
    }
  });
}

function renderCollections(slugs) {
  const box = document.getElementById("collections-list");
  box.innerHTML = "";

  const unique = Array.from(new Set(slugs)).filter(slug => slug && slug.trim());
  unique.forEach(slug => {
    const div = document.createElement("div");
    div.className = "item";
    div.dataset.entry = slug;
    div.textContent = slug;

    const ctrl = document.createElement("div");
    ctrl.className = "item-controls";

    const rename = document.createElement("button");
    rename.className = "icon-btn";
    rename.innerHTML = "âœŽ";
    rename.onclick = e => {
      e.stopPropagation();
      window._renameTarget = slug;
      document.getElementById("rename-input").value = slug;
      document.getElementById("rename-popup").style.display = "flex";
    };

    const del = document.createElement("button");
    del.className = "icon-btn";
    del.innerHTML = "âœ•";
    del.onclick = e => {
      e.stopPropagation();
      window._deleteTarget = slug;
      document.getElementById("delete-popup").style.display = "flex";
    };

    ctrl.appendChild(rename);
    ctrl.appendChild(del);
    div.appendChild(ctrl);

    div.onclick = () => {
      loadContent("collection", slug, slug, `https://raw.githubusercontent.com/lebron1212/bulletjournal/main/journals/collections/collection-${slug}.html`);
    };

    box.appendChild(div);
  });
}

  function createLineBlock(type = "text", text = "") {
  const block = document.createElement("div");

  if (type === "checkbox") {
    block.className = "entry-line";

    const cb = document.createElement("input");
    cb.type = "checkbox";
    cb.onchange = saveContent;

    const content = document.createElement("div");
    content.className = "line-text";
    content.contentEditable = true;
    content.innerHTML = text;

    block.appendChild(cb);
    block.appendChild(content);
  } else {
    block.className = "line-text";
    block.contentEditable = true;
    block.innerHTML = text;
  }

  return block;
}



// Utility: Place caret at start of node
function placeCaretAtStart(node) {
  const range = document.createRange();
  const sel = window.getSelection();
  range.setStart(node, 0);
  range.collapse(true);
  sel.removeAllRanges();
  sel.addRange(range);
  node.focus?.();
}

// Utility: Place caret at end of node
function placeCaretAtEnd(node) {
  const range = document.createRange();
  const sel = window.getSelection();
  range.selectNodeContents(node);
  range.collapse(false);
  sel.removeAllRanges();
  sel.addRange(range);
  node.focus?.();
}


// INIT
window.onload = () => {
  bindPopupKeys('collection-popup', createCollection, toggleCollectionPopup);
bindPopupKeys('rename-popup', confirmRename, hideRenamePopup);
bindPopupKeys('delete-popup', confirmDelete, hideDeletePopup);
journalContent = document.getElementById("journal-content");
journalContent.addEventListener("keydown", (e) => {
  const active = document.activeElement;
  if (!active || !active.isContentEditable) return;

  const parent = active.closest("[data-id]");
  if (!parent) return;

  const blockId = parent.dataset.id;
  const blockIndex = blocks.findIndex(b => b.id === blockId);
  if (blockIndex === -1) return;

  const block = blocks[blockIndex];
  const sel = window.getSelection();
  const range = sel?.getRangeAt(0);
  const caretOffset = range?.startOffset ?? 0;

  // ENTER
  if (e.key === "Enter" && !e.shiftKey) {
  e.preventDefault();

  const selection = window.getSelection();
  const range = selection.getRangeAt(0);

  // Clone "before" and "after" contents
  const beforeRange = range.cloneRange();
  beforeRange.setStart(active, 0);
  const beforeContent = beforeRange.cloneContents();

  const afterRange = range.cloneRange();
  afterRange.setEnd(active, active.childNodes.length);
  const afterContent = afterRange.cloneContents();

  // Extract HTML from both
  const tempDiv = document.createElement("div");
  tempDiv.appendChild(beforeContent);
  const beforeHTML = tempDiv.innerHTML;

  tempDiv.innerHTML = "";
  tempDiv.appendChild(afterContent);
  const afterHTML = tempDiv.innerHTML;

  // Convert current block if empty and was todo/list
  if (beforeHTML.trim() === "" && (block.type === "todo" || block.type === "list")) {
    blocks[blockIndex] = createBlock("text", "");
    renderBlocks();
    const el = document.querySelector(`[data-id="${blocks[blockIndex].id}"]`);
    if (el) placeCaretAtStart(el);
    saveBlocks();
    return;
  }

  block.content = beforeHTML;
  let newType = block.type;

  if (beforeHTML.trim() === "" && (block.type === "todo" || block.type === "list")) {
    newType = "text";
  }

  const createdBlock = createBlock(newType, afterHTML);
  blocks.splice(blockIndex + 1, 0, createdBlock);
  renderBlocks();

  const el = document.querySelector(`[data-id="${createdBlock.id}"]`);
  if (el) {
    placeCaretAtStart(el);
    document.execCommand("removeFormat");
  }

  saveBlocks();
  return;
}

  // BACKSPACE
  if (e.key === "Backspace" && caretOffset === 0) {
    e.preventDefault();

    const prev = blocks[blockIndex - 1];
    if (block.content === "") {
      if (block.type !== "text") {
        blocks[blockIndex] = createBlock("text", "");
        renderBlocks();
        const el = document.querySelector(`[data-id="${blocks[blockIndex].id}"]`);
        if (el) placeCaretAtStart(el);
        saveBlocks();
        return;
      }

      blocks.splice(blockIndex, 1);
      renderBlocks();
      const el = document.querySelector(`[data-id="${prev?.id}"]`);
      if (el) placeCaretAtEnd(el);
      saveBlocks();
      return;
    }

    // Merge
    if (prev) {
      prev.content += block.content;
      blocks.splice(blockIndex, 1);
      renderBlocks();
      const el = document.querySelector(`[data-id="${prev.id}"]`);
      if (el) placeCaretAtEnd(el);
      saveBlocks();
    }

    return;
  }

  // COMMAND MODE
  if (e.key === "/" && !e.metaKey && !e.ctrlKey && !e.altKey) {
    isCommandMode = true;
    commandBuffer = "/";
    window._targetBlock = parent;
    openCommandPalette();
    return;
  }

  if (e.key === "Escape" && isCommandMode) {
    isCommandMode = false;
    commandBuffer = "";
    closeCommandPalette();
    return;
  }
});

  
  // âœ… Global shortcuts (moved here to fix journalContent reference error)
  document.addEventListener("keydown", (e) => {
   if ((e.metaKey || e.ctrlKey) && e.key === "z" && !e.shiftKey) {
      undo();
      e.preventDefault();
    } else if ((e.metaKey || e.ctrlKey) && (e.key === "Z" || (e.shiftKey && e.key === "z"))) {
      redo();
      e.preventDefault();
    } else if ((e.metaKey || e.ctrlKey) && e.shiftKey && e.key.toLowerCase() === "c") {
      e.preventDefault();
      const newDiv = document.createElement("div");
      newDiv.innerHTML = "<br>";
      journalContent.appendChild(newDiv);
      placeCaretAtStart(newDiv);
      saveContent();
    }
  });

  // Save on input
  journalContent.addEventListener("input", () => {
    saveContent();
  });

  // Load & init
  recentEntries = JSON.parse(localStorage.getItem("recent-entries") || "[]");
  renderRecents();
  loadCollectionsList();

  const today = getTodaySlug();
  const yest = getTodaySlug(-1);
  const tomo = getTodaySlug(1);

  document.querySelector('[data-entry="today"]').onclick = () =>
    loadContent("daily", today, "DAILY LOG", `https://raw.githubusercontent.com/lebron1212/bulletjournal/main/journals/indexes/journal-${today}.html`);
  document.querySelector('[data-entry="yesterday"]').onclick = () =>
    loadContent("daily", yest, "DAILY LOG", `https://raw.githubusercontent.com/lebron1212/bulletjournal/main/journals/indexes/journal-${yest}.html`);
  document.querySelector('[data-entry="tomorrow"]').onclick = () =>
    loadContent("daily", tomo, "DAILY LOG", `https://raw.githubusercontent.com/lebron1212/bulletjournal/main/journals/indexes/journal-${tomo}.html`);

  loadContent("daily", today, "DAILY LOG", `https://raw.githubusercontent.com/lebron1212/bulletjournal/main/journals/indexes/journal-${today}.html`);
document.getElementById("journal-content").addEventListener("click", e => {
  const content = document.getElementById("journal-content");
  const target = e.target;

  // âœ… If you clicked on a line, focus it like normal
  const entry = target.closest(".entry-line");
  if (entry && !target.classList.contains("line-text")) {
    const text = entry.querySelector(".line-text");
    if (text) text.focus();
    return;
  }

  // âœ… If you clicked directly on a line-text, let default behavior continue
  if (target.classList.contains("line-text")) return;

  // âœ… If you clicked an <hr> (divider), add a new line after it
  if (target.tagName === "HR") {
    const newLine = createLineBlock("text", "");
    content.insertBefore(newLine, target.nextSibling);
    placeCaretAtStart(newLine);
    saveContent();
    return;
  }

  if (target === content && target === content.lastElementChild) {
  const newBlock = createBlock("text", "");
  blocks.push(newBlock);
  renderBlocks();
  const el = document.querySelector(`[data-id=\"${newBlock.id}\"]`);
  if (el) placeCaretAtStart(el);
  saveBlocks();
}
});

  const commandPalette = document.getElementById("command-palette");
const commandSearch = document.getElementById("command-search");
const commandOptionsBox = document.getElementById("command-options");

const COMMANDS = [
  { name: "/todo", label: "Checkbox" },
  { name: "/divider", label: "Divider" },
  { name: "/list", label: "List Item" }
];

let paletteActive = false;
let selectedIndex = 0;

  function openCommandPalette() {
  const sel = window.getSelection();
  if (!sel.rangeCount) return;

  const range = sel.getRangeAt(0).cloneRange();
  let rect = range.getBoundingClientRect();

  // Fallback for collapsed empty lines
  if (rect.width === 0 && rect.height === 0) {
    const span = document.createElement("span");
    span.textContent = "\u200b"; // zero-width space
    range.insertNode(span);
    rect = span.getBoundingClientRect();
    span.remove();
  }

  const wrapper = document.getElementById("journal-wrapper");
  const wrapperRect = wrapper.getBoundingClientRect();

  const palette = commandPalette;
  palette.style.display = "block";

  let left = rect.left + window.scrollX;
let top = rect.bottom + window.scrollY + 4;

const paletteWidth = 300;
const paletteHeight = 200;

if (left + paletteWidth > window.innerWidth) {
  left = window.innerWidth - paletteWidth - 20; // 20px padding from edge
}

if (top + paletteHeight > window.innerHeight) {
  top = rect.top + window.scrollY - paletteHeight - 10; // flip above
}

palette.style.left = `${left}px`;
palette.style.top = `${top}px`;
  paletteActive = true;
  commandSearch.value = "";
  renderCommandOptions(COMMANDS);
  commandSearch.focus();
}

function closeCommandPalette() {
  paletteActive = false;
  commandPalette.style.display = "none";
  selectedIndex = 0;

  // â¤µ Refocus to journal content
  journalContent.focus();
}

function renderCommandOptions(filtered) {
  commandOptionsBox.innerHTML = "";
  filtered.forEach((cmd, i) => {
    const div = document.createElement("div");
    div.textContent = cmd.label;
    div.className = "command-option" + (i === selectedIndex ? " active" : "");
    div.onclick = () => {
      applyCommand(cmd.name);
      closeCommandPalette();
    };
    commandOptionsBox.appendChild(div);
  });
}

commandSearch.addEventListener("input", () => {
  const val = commandSearch.value.toLowerCase();
  const matches = COMMANDS.filter(c => c.name.includes(val) || c.label.toLowerCase().includes(val));
  renderCommandOptions(matches);
});

commandSearch.addEventListener("keydown", e => {
  const visible = Array.from(commandOptionsBox.children);
  if (e.key === "ArrowDown") {
    selectedIndex = (selectedIndex + 1) % visible.length;
    renderCommandOptions(COMMANDS);
    e.preventDefault();
  } else if (e.key === "ArrowUp") {
    selectedIndex = (selectedIndex - 1 + visible.length) % visible.length;
    renderCommandOptions(COMMANDS);
    e.preventDefault();
  } else if (e.key === "Enter") {
    visible[selectedIndex]?.click();
    e.preventDefault();
  } else if (e.key === "Escape") {
    closeCommandPalette();
    e.preventDefault();
  }
});

function applyCommand(cmd) {
  const parent = window._targetBlock;
  if (!parent) return;

  const blockId = parent.dataset.id;
  const blockIndex = blocks.findIndex(b => b.id === blockId);
  if (blockIndex === -1) return;

  let block = blocks[blockIndex];

  if (cmd === "/todo") {
    block.type = "todo";
    block.props = { checked: false };
    // Retain text
  } else if (cmd === "/divider") {
    const divider = createBlock("divider", "");
    blocks.splice(blockIndex + 1, 0, divider);
  } else if (cmd === "/list") {
    block.type = "list";
    block.content = "";
  }

  renderBlocks();

  // Refocus the newly updated block
  const el = document.querySelector(`[data-id="${block.id}"]`);
  if (el) placeCaretAtStart(el);

  saveBlocks();
}

  function bindPopupKeys(popupId, onEnter, onEscape) {
  const popup = document.getElementById(popupId);
  const input = popup.querySelector('input');
  if (!input) return;

  input.addEventListener('keydown', e => {
    if (e.key === "Enter") {
      e.preventDefault();
      onEnter();
    }
    if (e.key === "Escape") {
      e.preventDefault();
      onEscape();
    }
  });
}
  // Click outside command palette to close
document.addEventListener("mousedown", (e) => {
  if (paletteActive && !commandPalette.contains(e.target) && !e.target.closest(".entry-line")) {
    closeCommandPalette();
  }
});

// Escape key to close command palette globally
document.addEventListener("keydown", (e) => {
  if (paletteActive && e.key === "Escape") {
    closeCommandPalette();
  }
});
};
</script>
</body>
</html>
